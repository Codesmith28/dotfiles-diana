#!/bin/bash

# color codes
RESTORE='\033[0m'
NC='\033[0m'
BLACK='\033[00;30m'
RED='\033[00;31m'
GREEN='\033[00;32m'
YELLOW='\033[00;33m'
BLUE='\033[00;34m'
PURPLE='\033[00;35m'
CYAN='\033[00;36m'
SEA="\\033[38;5;49m"
LIGHTGRAY='\033[00;37m'
LBLACK='\033[01;30m'
LRED='\033[01;31m'
LGREEN='\033[01;32m'
LYELLOW='\033[01;33m'
LBLUE='\033[01;34m'
LPURPLE='\033[01;35m'
LCYAN='\033[01;36m'
WHITE='\033[01;37m'
OVERWRITE='\e[1A\e[K'

# emoji codes
CHECK_MARK="${GREEN}\xE2\x9C\x94${NC}"
X_MARK="${RED}\xE2\x9C\x96${NC}"
PIN="${RED}\xF0\x9F\x93\x8C${NC}"
CLOCK="${GREEN}\xE2\x8C\x9B${NC}"
ARROW="${SEA}\xE2\x96\xB6${NC}"
BOOK="${RED}\xF0\x9F\x93\x8B${NC}"
HOT="${ORANGE}\xF0\x9F\x94\xA5${NC}"
WARNING="${RED}\xF0\x9F\x9A\xA8${NC}"
RIGHT_ANGLE="${GREEN}\xE2\x88\x9F${NC}"

DOTFILES_LOG="$HOME/.dotfiles.log"
DOTFILES_DIR="$HOME/dotfiles"

set -e

# Paths
REPO="dianaw353/dotfiles"
REPO_URL="https://github.com/$REPO.git"

# Default to stable
MODE="stable"

function print_help {
  cat << EOF
Usage: $0 [options]

META OPTIONS 
  --help                     show list of command-line options

BRANCH
  stable                     Use the stable release from GitHub. This will download the latest release as a ZIP file and extract it.
  rolling                    Clone the latest version directly from the GitHub repository. This will use git to clone the repository.
  

EOF
}

# Parse flags
while [[ $# -gt 0 ]]; do
  case $1 in
    stable)
      MODE="stable"
      shift
      ;;
    rolling)
      MODE="rolling"
      shift
      ;;
    -h|--help)
      print_help
      exit 0
      ;;
    *)
      echo "Invalid option: $1"
      print_help
      exit 1
      ;;
  esac
done

# _header colorize the given argument with spacing
function _task {
  # if _task is called while a task was set, complete the previous
  if [[ $TASK != "" ]]; then
    printf "${OVERWRITE}${LGREEN} [✓]  ${LGREEN}${TASK}\n"
  fi
  # set new task title and print
  TASK=$1
  printf "${LBLACK} [ ]  ${TASK} \n${LRED}"
}

# _cmd performs commands with error checking
function _cmd {
  # create log if it doesn't exist
  if ! [[ -f $DOTFILES_LOG ]]; then
    touch $DOTFILES_LOG
  fi
  # empty conduro.log
  > $DOTFILES_LOG
  # hide stdout, on error we print and exit
  if eval "$1" 1> /dev/null 2> $DOTFILES_LOG; then
    return 0 # success
  fi
  # read error from log and add spacing
  printf "${OVERWRITE}${LRED} [X]  ${TASK}${LRED}\n"
  while read line; do
    printf "      ${line}\n"
  done < $DOTFILES_LOG
  printf "\n"
  # remove log file
  rm $DOTFILES_LOG
  # exit installation
  exit 1
}

function _clear_task {
  TASK=""
}

function _task_done {
  printf "${OVERWRITE}${LGREEN} [✓]  ${LGREEN}${TASK}\n"
  _clear_task
}

function arch_setup() {
  if ! [ -x "$(command -v ansible)" ]; then
    _task "Installing Ansible"
    _cmd "sudo pacman -Sy --noconfirm"
    _cmd "sudo pacman -S --noconfirm ansible"
    _cmd "sudo pacman -S --noconfirm python-argcomplete"
    # _cmd "sudo activate-global-python-argcomplete3"
  fi
  if ! pacman -Q python3 >/dev/null 2>&1; then
    _task "Installing Python3"
    _cmd "sudo pacman -S --noconfirm python"
  fi
  if ! pacman -Q python-pip >/dev/null 2>&1; then
    _task "Installing Python3 Pip"
    _cmd "sudo pacman -S --noconfirm python-pip"
  fi
  if ! pip3 list | grep watchdog >/dev/null 2>&1; then
    _task "Installing Python3 Watchdog"
    _cmd "sudo pacman -S --noconfirm python-watchdog"
  fi
  if ! pacman -Q openssh >/dev/null 2>&1; then
    _task "Installing OpenSSH"
    _cmd "sudo pacman -S --noconfirm openssh"
  fi
  if ! pacman -Q unzip >/dev/null 2>&1; then
    _task "Installing Unzip"
    _cmd "sudo pacman -S --noconfirm unzip"
  fi
}

update_ansible_galaxy() {
  local os=$1
  local os_requirements=""
  _task "Updating Ansible Galaxy"
  if [ -f "$DOTFILES_DIR/requirements/$os.yml" ]; then
    _task "${OVERWRITE}Updating Ansible Galaxy with OS Config: $os"
    os_requirements="$DOTFILES_DIR/requirements/$os.yml"
  fi
  if [ -f "$DOTFILES_DIR/requirements/common.yml" ]; then
    _cmd "ansible-galaxy install -r $DOTFILES_DIR/requirements/common.yml $os_requirements"
  else
    printf "${LYELLOW} [-] $DOTFILES_DIR/requirements/common.yml does not exist. Skipping Ansible Galaxy update.\n"
  fi
}

# Function to get the latest release tag
get_latest_release() {
  curl --silent "https://api.github.com/repos/$REPO/releases/latest" | \
    grep '"tag_name":' | \
    sed -E 's/.*"([^"]+)".*/\1/'
}

# Function to get the latest zip URL
get_latest_zip() {
  curl --silent "https://api.github.com/repos/$REPO/releases/latest" | \
    grep '"zipball_url":' | \
    sed -E 's/.*"([^"]+)".*/\1/'
}

# Function to download the latest release and extract it
download_latest_release() {
  local zip_url=$(get_latest_zip)
  local zip_file="$HOME/dotfiles_latest.zip"

  _task "Deleting existing dotfiles directory contents"
  _cmd "rm -rf $DOTFILES_DIR/*"

  _task "Downloading the latest release from GitHub"
  _cmd "curl -L -o $zip_file $zip_url"

  _task "Extracting the downloaded zip file"
  _cmd "unzip -o $zip_file -d $HOME/dotfiles_temp"

  _task "Renaming the extracted folder to dotfiles"
  _cmd "mv $HOME/dotfiles_temp/*dotfiles-* $DOTFILES_DIR"

  _task "Cleaning up"
  _cmd "rm -rf $zip_file $HOME/dotfiles_temp"
}

# Function to clone the repository for rolling
clone_repository() {
  _task "Cloning the repository"
  _cmd "rm -rf $DOTFILES_DIR"
  _cmd "git clone $REPO_URL $DOTFILES_DIR"
}

source /etc/os-release
_task "Loading Setup for detected OS: $ID"
case $ID in
  arch)
    arch_setup
    ;;
  *)
    _task "Unsupported OS"
    _cmd "echo 'Unsupported OS'"
    ;;
esac

# Backup dotfiles
backup_dotfiles() {
  local backup_dir="$HOME/dotfiles_backup/$(date +'%Y%m%d_%H%M%S')"
  _task "Creating backup directory: $backup_dir"
  if mkdir -p "$backup_dir"; then
    _task_done
  else
    printf "${LYELLOW} [-] Failed to create backup directory. Skipping backup.\n"
    return 1
  fi

  _task "Backing up .config directory"
  if cp -r "$HOME/.config" "$backup_dir" 2>/dev/null; then
    _task_done
  else
    printf "${LYELLOW} [-] Couldn't find .config to create a back up directory. Skipping.\n"
  fi

  _task "Backing up .zshrc"
  if cp "$HOME/.zshrc" "$backup_dir" 2>/dev/null; then
    _task_done
  else
    printf "${LYELLOW} [-] Couldn't find .zshrc to create a backup. Skipping.\n"
  fi

  _task "Backing up .bashrc"
  if cp "$HOME/.bashrc" "$backup_dir" 2>/dev/null; then
    _task_done
  else
    printf "${LYELLOW} [-] Couldn't find .bashrc to create a backup. Skipping.\n"
  fi
}

backup_dotfiles

if [[ $MODE == "rolling" ]]; then
  clone_repository
else
  download_latest_release
fi

update_ansible_galaxy $ID

